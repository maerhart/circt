//===- ExtractOps.td - LLHD extract operations -------------*- tablegen -*-===//
//
// This describes the MLIR ops for field and slice extractions.
//
//===----------------------------------------------------------------------===//

def LLHD_ExtsOp : LLHD_Op<"exts", [
    NoSideEffect,
    PredOpTrait<
      "'start' + size of the slice have to be smaller or equal to the 'target' "
      "size",
      CPred<"$start.cast<IntegerAttr>().getInt() + this->getSliceSize() <= "
            "this->getTargetSize()">>,
    SameTypeArbitraryWidth<
      "'target' and 'result' have to be both either signless integers, signals "
      "or vectors with the same element type",
      "$target", "$result">
  ]> {
  let summary = "Extract a slice of consecutive elements.";
  let description = [{
    The `llhd.exts` operation allows access to a slice of the `$target`
    operand. The `$start` attribute defines the index of the first element.
    The return type is the same as `$target` but with the width of the
    specified result type.
    If `%target` is a signal, a new subsignal aliasing the slice will be
    returned.

    Example:

    ```mlir
    %0 = llhd.const 123 : i32
    %1 = llhd.exts %0, 0 : i32 -> i2

    %2 = llhd.sig %0 : i32
    %3 = llhd.exts %2, 0 : !llhd.sig<i32> -> !llhd.sig<i5>
    ```
  }];

  let arguments = (ins
    AnyTypeOf<[AnySignlessInteger, AnyVector,
               LLHD_SigType<[AnySignlessInteger, AnyVector]>]>: $target,
    IndexAttr: $start);

  let results = (outs
    AnyTypeOf<[AnySignlessInteger, AnyVector,
               LLHD_SigType<[AnySignlessInteger, AnyVector]>]>: $result);

  let assemblyFormat = [{
    $target `,` $start attr-dict `:` type($target) `->` type($result)
  }];

  let extraClassDeclaration = [{
    unsigned getSliceSize()  { return getLLHDTypeWidth(result().getType()); }
    unsigned getTargetSize() { return getLLHDTypeWidth(target().getType()); }
  }];
}

def LLHD_DextsOp : LLHD_Op<"dexts", [
    NoSideEffect,
    SameTypeArbitraryWidth<
      "'target' and 'result' types have to match apart from their width",
      "$target", "$result">,
    PredOpTrait<
      "the result width cannot be larger than the target operand width",
      CPred<"this->getTargetWidth() >= this->getSliceWidth()">>
  ]> {
  let summary = "Dynamically extract a slice of consecutive elements";
  let description = [{
    The `llhd.dexts` operation allows to dynamically access a slice of the
    `$target` operand, starting at the index given by the `$start` operand.
    The resulting slice length is defined by the result type.
    The `$target` operand kind has to match the result kind.
    If `$target` is a vector, only the number of elements can change, while
    the element type has to remain the same.

    Example:

    ```mlir
    %0 = llhd.const 0x0f0 : i12
    %1 = llhd.const 4 : i3

    %3 = llhd.dexts %0, %1 : (i12, i3) -> i4    // %3: 0xf
    ```
  }];

  let arguments = (ins
    AnyTypeOf<[AnySignlessInteger, AnyVector,
               LLHD_SigType<[AnySignlessInteger, AnyVector]>]>: $target,
    AnySignlessInteger: $start);

  let results = (outs
    AnyTypeOf<[AnySignlessInteger, AnyVector,
               LLHD_SigType<[AnySignlessInteger, AnyVector]>]>: $result);

  let assemblyFormat = [{
    operands attr-dict `:` functional-type(operands, results)
  }];

  let extraClassDeclaration = [{
    unsigned getSliceWidth()  { return getLLHDTypeWidth(result().getType()); }
    unsigned getTargetWidth() { return getLLHDTypeWidth(target().getType()); }
  }];
}

def LLHD_ExtfOp : LLHD_Op<"extf", [
    NoSideEffect,
    PredOpTrait<"'index' has to be smaller than the 'target' size",
      CPred<"$index.cast<IntegerAttr>().getInt() < getTargetWidth()">>,
    TypesMatchWith<"'result' type has to match type at 'index' of 'target', in "
      "case 'target'is a singal, consider the underlying types of the 'target' "
      "and 'result' signals",
      "target", "result",
      "($_self.isa<llhd::SigType>() "
        "? llhd::SigType::get("
          "getElementTypeAtIndex($index.cast<IntegerAttr>().getInt())) "
        ": getElementTypeAtIndex($index.cast<IntegerAttr>().getInt()))">
  ]> {
  let summary = "Extract an element from a vector or tuple";
  let description = [{
    The `llhd.extf` operation allows access to an element of the `$target`
    operand. The `$index` attribute defines the index of the element to extract.
    If `%target` is a signal, a new subsignal aliasing the field will be
    returned.

    Example:

    ```mlir
    %0 = constant dense<[1,2,3]> : vector<3xi8>
    %1 = llhd.extf %0, 0 : vector<3xi8> -> i8

    %2 = llhd.sig %0 : vector<3xi8>
    %3 = llhd.extf %2, 0 : !llhd.sig<vector<3xi8>> -> !llhd.sig<i8>

    %4 = llhd.const 8 : i16
    %5 = llhd.tuple %0, %4 : tuple<vector<3xi8>, i16>
    %6 = llhd.extf %5, 1 : tuple<vector<3xi8>, i16> -> i16
    ```
  }];

  let arguments = (ins AnyTypeOf<[
      AnyVector,
      AnyTuple,
      LLHD_SigType<[AnyVector, AnyTuple]>
    ]>: $target,
    IndexAttr: $index);

  let results = (outs AnyType: $result);

  let assemblyFormat = [{
    $target `,` $index attr-dict `:` type($target) `->` type($result)
  }];

  let extraClassDeclaration = [{
    unsigned getTargetWidth() { return getLLHDTypeWidth(target().getType()); };

    Type getElementTypeAtIndex(unsigned index) {
      Type targetType = target().getType();
      if (auto sig = targetType.dyn_cast<llhd::SigType>())
        targetType = sig.getUnderlyingType();
      if (auto vec = targetType.dyn_cast<VectorType>())
        return vec.getElementType();
      return targetType.dyn_cast<TupleType>().getTypes()[index];
    }
  }];
}

def LLHD_DextfOp : LLHD_Op<"dextf", [
  NoSideEffect,
  TypesMatchWith<"'result' must be the element type of the 'target' vector, in "
    "case 'target' is a signal of a vector, 'result' also is a signal of the "
    "vector element type",
    "target", "result",
    "($_self.isa<llhd::SigType>() ? llhd::SigType::get(getElementType()) "
                                 ": getElementType())">
  ]> {
  let summary = [{
    Dynamically extract an element from a vector or signal of vector.
  }];
  let description = [{
    The `llhd.dextf` operation allows to dynamically access an element of the
    `$target` operand. The `$index` operand defines the index of the element to
    extract. If `%target` is a signal, a new subsignal aliasing the element will
    be returned.

    Example:

    ```mlir
    %index = llhd.const 1 : i2

    %0 = constant dense<[1,2,3]> : vector<3xi8>
    %1 = llhd.dextf %0, %index : (vector<3xi8>, i2) -> i8

    %2 = llhd.sig %0 : vector<3xi8>
    %3 = llhd.dextf %2, %index : (!llhd.sig<vector<3xi8>>, i2) -> !llhd.sig<i8>
    ```
  }];

  let arguments = (ins
    AnyTypeOf<[AnyVector, LLHD_SigType<[AnyVector]>]>: $target,
    AnySignlessInteger: $index);

  let results = (outs AnyType: $result);

  let assemblyFormat = [{
    $target `,` $index attr-dict `:` functional-type(operands, results)
  }];

  let extraClassDeclaration = [{
    unsigned getTargetWidth() { return getLLHDTypeWidth(target().getType()); }

    Type getElementType() {
      Type targetType = target().getType();
      if (auto sig = targetType.dyn_cast<llhd::SigType>())
        targetType = sig.getUnderlyingType();
      return targetType.dyn_cast<VectorType>().getElementType();
    }
  }];
}
